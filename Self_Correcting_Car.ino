/*This piece of code allows a car to reverse a bit and turn around when a shock is detected.Motor controls go to pin 3, 5, 6, 9. Motor 1 is the one on the left, Motor 2 is the one on the right. */#include<CurieIMU.h>//Motor pin definitions: const int m1p=3;const int m1n=5;const int m2p=6;const int m2n=9;int m1pState = 0;int m1nState = 0;int m2pState = 0;int m2nState = 0;//Setup for LEDboolean blink = true;//Reactionstatic void shock(void) {  //Generating random number for change of direction after collision  randomSeed(analogRead(0));  long dir = long(random(0,2));  //Printing acceleration value for fine-tuning  int ax, ay, az;  CurieIMU.readAccelerometer(ax, ay, az);  Serial.println(ax);  //Changing LED status to   blink = !blink;    //Analises shock direction, if it's on negative direction(BLE to USB) along X-axis then change direction, else do nothing    if (CurieIMU.getInterruptStatus(CURIE_IMU_SHOCK)) {    int tTurn = 250;    if (CurieIMU.shockDetected(Z_AXIS, POSITIVE)){      backward();      mov();      delay(tTurn);      if (dir){        left();        mov();        delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }        if (CurieIMU.shockDetected(Z_AXIS, NEGATIVE)){      backward();      mov();      delay(tTurn);      blink = !blink;      if (dir){        left();        mov();      delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }    if (CurieIMU.shockDetected(X_AXIS, POSITIVE)){      backward();      mov();      delay(tTurn);      if (dir){        left();        mov();        delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }        if (CurieIMU.shockDetected(X_AXIS, NEGATIVE)){      backward();      mov();      delay(tTurn);      blink = !blink;      if (dir){        left();        mov();      delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }    if (CurieIMU.shockDetected(Y_AXIS, POSITIVE)){      backward();      mov();      delay(tTurn);      if (dir){        left();        mov();        delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }        if (CurieIMU.shockDetected(Y_AXIS, NEGATIVE)){      backward();      mov();      delay(tTurn);      blink = !blink;      if (dir){        left();        mov();      delay(tTurn);      }      else{        right();        mov();        delay(tTurn);      }    }  }}//Setup of Serial port and CurieIMU moudulevoid setup() {    CurieIMU.begin();  Serial.begin(9600);  //while(!Serial);  CurieIMU.setAccelerometerRate(25);  CurieIMU.interrupts(CURIE_IMU_SHOCK);  CurieIMU.attachInterrupt(shock);  CurieIMU.setAccelerometerRange(5);  Serial.println("Initialized");    //Setup parameters for Curie IMU shock detection.   CurieIMU.setDetectionThreshold(CURIE_IMU_SHOCK, 1000);  CurieIMU.setDetectionDuration(CURIE_IMU_SHOCK, 5);    //Setup for motor control output  pinMode(m1p, OUTPUT);  pinMode(m1n, OUTPUT);  pinMode(m2p, OUTPUT);  pinMode(m2n, OUTPUT);  pinMode(LED_BUILTIN, OUTPUT);}void loop() {  digitalWrite(LED_BUILTIN, blink);  forward();  mov();}//Actionsvoid forward(){  m1pState = 192;  m1nState = 0;   m2pState = 192;  m2nState = 0;}void backward(){  m1pState = 0;  m1nState = 192;  m2pState = 0;  m2nState = 192;}void left(){  m1pState = 0;  m1nState = 192;  m2pState = 192;   m2nState = 0;}void right(){  m1pState = 192;  m1nState = 0;  m2pState = 0;  m2nState = 192;}void mov(){  analogWrite(m1p, m1pState);  analogWrite(m1n, m1nState);  analogWrite(m2p, m2pState);  analogWrite(m2n, m2nState);}